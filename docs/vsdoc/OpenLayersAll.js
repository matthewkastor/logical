
  
/* vsdoc for _global_ */

(function (window) {
    

    window._global_ = {
        /// <summary></summary>
        /// <returns type="_global_"/>
                
    };

    var $x = window._global_;
    $x.__namespace = "true";
    $x.__typeName = "_global_";
})(this);

  

  
/* vsdoc for logical */

(function (window) {
    

    window.logical = {
        /// <summary>Logical functions for JavaScript. <br/>
        /// /// <img src=&amp;quot;../../Logical_connectives_Hasse_diagram.svg.png&amp;quot; style=&amp;quot;width:100%&amp;quot; /></summary>
        /// <returns type="logical"/>
      
        /// <field name="f" type="">alias for fals</field>
        f : {}, 
      
        /// <field name="contradiction" type="">alias for fals</field>
        contradiction : {}, 
      
        /// <field name="Opq" type="">alias for fals</field>
        Opq : {}, 
      
        /// <field name="t" type="">alias for tru</field>
        t : {}, 
      
        /// <field name="tautology" type="">alias for tru</field>
        tautology : {}, 
      
        /// <field name="Vpq" type="">alias for tru</field>
        Vpq : {}, 
      
        /// <field name="negation" type="">alias for not</field>
        negation : {}, 
      
        /// <field name="conjunction" type="">alias for and</field>
        conjunction : {}, 
      
        /// <field name="Kpq" type="">alias for and</field>
        Kpq : {}, 
      
        /// <field name="abdjunction" type="">alias for materialNonImplication</field>
        abdjunction : {}, 
      
        /// <field name="doesNotImply" type="">alias for materialNonImplication</field>
        doesNotImply : {}, 
      
        /// <field name="butNot" type="">alias for materialNonImplication</field>
        butNot : {}, 
      
        /// <field name="Xp" type="">alias for materialNonImplication</field>
        Xp : {}, 
      
        /// <field name="Lpq" type="">alias for materialNonImplication</field>
        Lpq : {}, 
      
        /// <field name="Ipq" type="">alias for p</field>
        Ipq : {}, 
      
        /// <field name="isNotImpliedBy" type="">alias for converseMaterialNonImplication</field>
        isNotImpliedBy : {}, 
      
        /// <field name="notBut" type="">alias for converseMaterialNonImplication</field>
        notBut : {}, 
      
        /// <field name="converseNonImplication" type="">alias for converseMaterialNonImplication</field>
        converseNonImplication : {}, 
      
        /// <field name="Xq" type="">alias for converseMaterialNonImplication</field>
        Xq : {}, 
      
        /// <field name="Mpq" type="">alias for converseMaterialNonImplication</field>
        Mpq : {}, 
      
        /// <field name="Hpq" type="">alias for q</field>
        Hpq : {}, 
      
        /// <field name="exclusiveDisjunction" type="">alias for xor</field>
        exclusiveDisjunction : {}, 
      
        /// <field name="Jpq" type="">alias for xor</field>
        Jpq : {}, 
      
        /// <field name="disjunction" type="">alias for or</field>
        disjunction : {}, 
      
        /// <field name="Apq" type="">alias for or</field>
        Apq : {}, 
      
        /// <field name="Xpq" type="">alias for nor</field>
        Xpq : {}, 
      
        /// <field name="jointDenial" type="">alias for nor</field>
        jointDenial : {}, 
      
        /// <field name="equality" type="">alias for xnor</field>
        equality : {}, 
      
        /// <field name="equals" type="">alias for xnor</field>
        equals : {}, 
      
        /// <field name="ifAndOnlyIf" type="">alias for xnor</field>
        ifAndOnlyIf : {}, 
      
        /// <field name="iff" type="">alias for xnor</field>
        iff : {}, 
      
        /// <field name="biconditional" type="">alias for xnor</field>
        biconditional : {}, 
      
        /// <field name="materialBiconditional" type="">alias for xnor</field>
        materialBiconditional : {}, 
      
        /// <field name="Epq" type="">alias for xnor</field>
        Epq : {}, 
      
        /// <field name="Nq" type="">alias for not_q</field>
        Nq : {}, 
      
        /// <field name="Gpq" type="">alias for not_q</field>
        Gpq : {}, 
      
        /// <field name="isImpliedBy" type="">alias for converseMaterialImplication</field>
        isImpliedBy : {}, 
      
        /// <field name="converseImplication" type="">alias for converseMaterialImplication</field>
        converseImplication : {}, 
      
        /// <field name="XNq" type="">alias for converseMaterialImplication</field>
        XNq : {}, 
      
        /// <field name="Bpq" type="">alias for converseMaterialImplication</field>
        Bpq : {}, 
      
        /// <field name="Np" type="">alias for not_p</field>
        Np : {}, 
      
        /// <field name="Fpq" type="">alias for not_p</field>
        Fpq : {}, 
      
        /// <field name="materialConditional" type="">alias for materialImplication</field>
        materialConditional : {}, 
      
        /// <field name="materialConsequence" type="">alias for materialImplication</field>
        materialConsequence : {}, 
      
        /// <field name="implication" type="">alias for materialImplication</field>
        implication : {}, 
      
        /// <field name="implies" type="">alias for materialImplication</field>
        implies : {}, 
      
        /// <field name="conditional" type="">alias for materialImplication</field>
        conditional : {}, 
      
        /// <field name="XNp" type="">alias for materialImplication</field>
        XNp : {}, 
      
        /// <field name="Cpq" type="">alias for materialImplication</field>
        Cpq : {}, 
      
        /// <field name="Dpq" type="">alias for nand</field>
        Dpq : {}, 
      
        /// <field name="alternativeDenial" type="">alias for nand</field>
        alternativeDenial : {}, 
      
        /// <field name="thenIfElse" type="">alias for conditioned disjunction</field>
        thenIfElse : {}, 
      
        /// <field name="conditionalDisjunction" type="">alias for conditioned disjunction</field>
        conditionalDisjunction : {}, 
      
        /// <field name="ifThenElse" type="">alias for conditioned disjunction2</field>
        ifThenElse : {}, 
      
        /// <field name="conditionalDisjunction2" type="">alias for conditioned disjunction2</field>
        conditionalDisjunction2 : {}, 
      
        /// <field name="tools" type="">Contains utilities to help with using logical.</field>
        tools : {}, 
                
        fals: function() {
            /// <summary>Logical contradiction. <br/>
            /// <img src=&quot;../../0 contradiction false.png&quot; />
            /// <img src=&quot;../../0 contradiction false_ANSI.png&quot; />
            /// <img src=&quot;../../0 contradiction false summary.png&quot; /></summary>
            /// <returns type="">Returns false.</returns>
        }, 
        
        tru: function() {
            /// <summary>Logical tautology. <br/>
            /// <img src=&quot;../../1 tautology true.png&quot; />
            /// <img src=&quot;../../1 tautology true_ANSI.png&quot; />
            /// <img src=&quot;../../1 tautology true summary.png&quot; /></summary>
            /// <returns type="">Returns true.</returns>
        }, 
        
        identity: function(p) {
            /// <summary>Logical identity. <br/>
            /// <img src=&quot;../../01 identity.png&quot; />
            /// <img src=&quot;../../01 identity_ANSI.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <returns type="Boolean">Returns p.</returns>
        }, 
        
        not: function(p) {
            /// <summary>NOT. Logical negation. &lt;code&gt;!p&lt;/code&gt; <br/>
            /// <img src=&quot;../../10 negation.png&quot; />
            /// <img src=&quot;../../10 NOT_ANSI.png&quot; /></summary>
            /// <param name="p" type="Boolean"></param>
            /// <returns type="Boolean">Returns the negation of p.</returns>
        }, 
        
        and: function(p, q) {
            /// <summary>AND. Logical conjunction. &lt;code&gt;p &amp;&amp; q&lt;/code&gt; <br/>
            /// <img src=&quot;../../0001 conjunction.png&quot; />
            /// <img src=&quot;../../0001 AND_ANSI.png&quot; />
            /// <img src=&quot;../../0001 conjunction summary.png&quot; /></summary>
            /// <param name="p" type="Boolean"></param>
            /// <param name="q" type="Boolean"></param>
            /// <returns type="Boolean">Returns the conjunction of p and q.</returns>
        }, 
        
        materialNonImplication: function(p, q) {
            /// <summary>Material nonimplication. &lt;code&gt;p &amp;&amp; !q&lt;/code&gt; <br/>
            /// <img src=&quot;../../0010 material nonimplication.png&quot; />
            /// <img src=&quot;../../0010 material nonimplication_ANSI.png&quot; />
            /// <img src=&quot;../../0010 material nonimplication summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the material nonimplication of p and q.</returns>
        }, 
        
        p: function(p, q) {
            /// <summary>Projection of p. <br/>
            /// <img src=&quot;../../0011 proposition p.png&quot; />
            /// <img src=&quot;../../0011 proposition p_ANSI.png&quot; />
            /// <img src=&quot;../../0011 proposition p summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the value of p.</returns>
        }, 
        
        converseMaterialNonImplication: function(p, q) {
            /// <summary>Converse material nonimplication. &lt;code&gt;!p &amp;&amp; q&lt;/code&gt; <br/>
            /// <img src=&quot;../../0100 converse material nonimplication.png&quot; />
            /// <img src=&quot;../../0100 converse material nonimplication_ANSI.png&quot; />
            /// <img src=&quot;../../0100 converse material nonimplication summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the converse material nonimplication of p and q.</returns>
        }, 
        
        q: function(p, q) {
            /// <summary>Projection of q. <br/>
            /// <img src=&quot;../../0101 proposition q.png&quot; />
            /// <img src=&quot;../../0101 proposition q_ANSI.png&quot; />
            /// <img src=&quot;../../0101 proposition q summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the value of q.</returns>
        }, 
        
        xor: function(p, q) {
            /// <summary>Exclusive OR. &lt;code&gt;(p || q) &amp;&amp; (!(p &amp;&amp; q))&lt;/code&gt; <br/>
            /// <img src=&quot;../../0110 exclusive disjunction.png&quot; />
            /// <img src=&quot;../../0110 XOR_ANSI.png&quot; />
            /// <img src=&quot;../../0110 exclusive disjunction summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the exclusive disjunction of p and q.</returns>
        }, 
        
        or: function(p, q) {
            /// <summary>OR Logical disjunction. &lt;code&gt;p || q&lt;/code&gt; <br/>
            /// <img src=&quot;../../0111 disjunction.png&quot; />
            /// <img src=&quot;../../0111 OR_ANSI.png&quot; />
            /// <img src=&quot;../../0111 disjunction summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the disjunction of p and q.</returns>
        }, 
        
        nor: function(p, q) {
            /// <summary>NOR. The compliment of OR. &lt;code&gt;!(p || q)&lt;/code&gt; <br/>
            /// <img src=&quot;../../1000 joint denial.png&quot; />
            /// <img src=&quot;../../1000 NOR_ANSI.png&quot; />
            /// <img src=&quot;../../1000 joint denial summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the negated disjunction of p and q.</returns>
        }, 
        
        xnor: function(p, q) {
            /// <summary>Exclusive NOR. The complement of exclusive OR.
            ///  &lt;code&gt;!((p || q) &amp;&amp; (!(p &amp;&amp; q)))&lt;/code&gt; <br/>
            /// <img src=&quot;../../1001 material biconditional.png&quot; />
            /// <img src=&quot;../../1001 XNOR_ANSI.png&quot; />
            /// <img src=&quot;../../1001 material biconditional summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the negated exclusive disjunction of p and q.</returns>
        }, 
        
        not_q: function(p, q) {
            /// <summary>Negates q, ignoring p. &lt;code&gt;!q&lt;/code&gt; <br/>
            /// <img src=&quot;../../1010 not q.png&quot; />
            /// <img src=&quot;../../1010 not q_ANSI.png&quot; />
            /// <img src=&quot;../../1010 not q summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the negated value of q.</returns>
        }, 
        
        converseMaterialImplication: function(p, q) {
            /// <summary>Converse material implication. &lt;code&gt;p || !q&lt;/code&gt; <br/>
            /// <img src=&quot;../../1011 converse material implication.png&quot; />
            /// <img src=&quot;../../1011 converse material implication_ANSI.png&quot; />
            /// <img src=&quot;../../1011 converse material implication summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the converse material implication of p and q.</returns>
        }, 
        
        not_p: function(p, q) {
            /// <summary>Negates p, ignoring q. &lt;code&gt;!p&lt;/code&gt; <br/>
            /// <img src=&quot;../../1100 not p.png&quot; />
            /// <img src=&quot;../../1100 not p_ANSI.png&quot; />
            /// <img src=&quot;../../1100 not p summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the negated value of p.</returns>
        }, 
        
        materialImplication: function(p, q) {
            /// <summary>Material implication. &lt;code&gt;!p || q&lt;/code&gt; <br/>
            /// <img src=&quot;../../1101 material implication.png&quot; />
            /// <img src=&quot;../../1101 material implication_ANSI.png&quot; />
            /// <img src=&quot;../../1101 material implication summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the material implication of p and q.</returns>
        }, 
        
        nand: function(p, q) {
            /// <summary>NAND. Compliment of AND. &lt;code&gt;!(p &amp;&amp; q)&lt;/code&gt; <br/>
            /// <img src=&quot;../../1110 alternative denial.png&quot; />
            /// <img src=&quot;../../1110 NAND_ANSI.png&quot; />
            /// <img src=&quot;../../1110 alternative denial summary.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <returns type="Boolean">Returns the negated conjunction of p and q.</returns>
        }, 
        
        conditionedDisjunction: function(p, q, r) {
            /// <summary>Conditioned disjunction. &lt;code&gt;(!q || p) &amp;&amp; (q || r)&lt;/code&gt; Works just like
            ///  &lt;code&gt;if(q) { return p } else { return r }&lt;/code&gt;. Works just like the
            ///  conditional operator &lt;code&gt;q ? p : r&lt;/code&gt; <br>
            /// <img src=&quot;../../01000111 conditioned disjunction summary.png&quot; />
            /// <img src=&quot;../../01000111 CONDITIONED_DISJUNCTION_ANSI.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <param name="r" type="boolean"></param>
            /// <returns type="Boolean">Returns the conditioned disjunction of p, q, and r.</returns>
        }, 
        
        conditionedDisjunction2: function(p, q, r) {
            /// <summary>Conditioned disjunction. &lt;code&gt;(p &amp;&amp; q) || (!p &amp;&amp; r)&lt;/code&gt; Works just like
            ///  &lt;code&gt;if(p) { return q } else { return r }&lt;/code&gt;. Works just like the
            ///  conditional operator &lt;code&gt;p ? q : r&lt;/code&gt; <br>
            /// <img src=&quot;../../01010011 conditioned disjunction summary.png&quot; />
            /// <img src=&quot;../../01010011 CONDITIONED_DISJUNCTION_ANSI.png&quot; /></summary>
            /// <param name="p" type="boolean"></param>
            /// <param name="q" type="boolean"></param>
            /// <param name="r" type="boolean"></param>
            /// <returns type="Boolean">Returns the conditioned disjunction of p, q, and r.</returns>
        }
        
    };

    var $x = window.logical;
    $x.__namespace = "true";
    $x.__typeName = "logical";
})(this);

  

  
/* vsdoc for logical.tools */

(function (window) {
    window.logical = window.logical || {};

    window.logical.tools = {
        /// <summary>Contains utilities to help with using logical.</summary>
        /// <returns type="logical.tools"/>
                
        truthTableToBoolean: function(truthTable) {
            /// <summary>Converts values in truth tables to boolean values.</summary>
            /// <param name="truthTable" type="Array">An array of arrays containing truth table values.</param>
            /// <returns type="Array">Returns the truth table with all values converted to boolean
            ///  values.</returns>
        }, 
        
        testTruthTable: function(truth, logicalFunction) {
            /// <summary>Tests the output of the given logical function against the given truth table.</summary>
            /// <param name="truth" type="Array">The truth table.
            ///  The rows are arranged with the inputs on the left and the rightmost value
            ///  being the expected output. For testing logical and, the input 1,1 would
            ///  be expected to return 1, so the row for this input would be 1,1,1. For more
            ///  examples see the tests.</param>
            /// <param name="logicalFunction" type="Function">The logical function to test.</param>
            /// <returns type="Boolean">Returns true if everything checks out.</returns>
        }
        
    };

    var $x = window.logical.tools;
    $x.__namespace = "true";
    $x.__typeName = "logical.tools";
})(this);

  

